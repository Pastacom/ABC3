# ИДЗ №3
*Шиндяпкин Илья Дмитриевич БПИ-219*
## Задание
### Вариант №1
Разработать программу, вычисляющую с помощью степенного ряда с точностью не хуже 0,05% значение функции $\sqrt{1+x}$ для заданного параметра $x$.
***
Будем использовать частную биномиальную формулу ряда для этого случая. Формулу можно посмотреть здесь: http://mathprofi.ru/tablica_razlozhenij_funkcij_v_ryady.pdf
***
Допустимой областью значений для функции будет (-1, 1), потому что только тогда она сходится. Считаем значение функции до того момента, пока один из членов ряда не будет меньше по модулю нашей точности. Тогда можем отбросить этот член и далее идущие, а за результат взять сумму всех членов до первого отброшенного. Это возможно, поскольку наш ряд знакочередующийся.

## Часть на 4-6.
Программа сразу разработана на оценку 9, однако она соответствует критериям на 4-6.
Есть программы на ассемблере просто скомпилированные с флагами. И есть аналогичные файлы, но уже с рефакторингом. 
Они используют локальные переменные и функции с параметрами, для работы с числами с плавающей точкой. Использованы регистры для ускорения работы программы.

Коды на ассемблере прокомментированы. Указана связь переменных с регистрами и памятью на стеке, а так же связь регистров и переменных при возвращении из функций и передачи их, как параметров, то есть эквивалентное представление переменных и регистров/памяти на стеке на различных языках. 

В этой же директории есть папка с тестами, где есть входные данные и соответствующие им выходные. Все программы протестированы на входных данных и выдают корректные результаты. 

**Дублирование тестовых данных**:

Тест 1:

	Входные данные:
	0.063169

	Выходные данные:
    1.031585

Тест 2:

	Входные данные:
	-0.327146
	
	Выходные данные:
    0.820861

Тест 3:

	Входные данные:
	0.442199

	Выходные данные:
    1.200567


Тест 4:

	Входные данные:
	-0.944151

	Выходные данные:
    0.241352

Тест 5:

	Входные данные:
	0.537461

	Выходные данные:
    1.240292

Тест 6:

	Входные данные:
	0.856388

	Выходные данные:
    1.362219

Тест 7:

	Входные данные:
	-0.370698
	
	Выходные данные:
    0.793552

***
Из модифицированной версии кода на ассемблере убраны ненужные макросы с помощью компиляции с флагами. 

Код на С был скомпилирован со следующими флагами:
-masm=intel (для использования синтаксиса Intel)
-fno-asynchronous-unwind-tables (отключает генерацию отладочной информации)
-fno-jump-tables (отключает использование jump-таблиц в switch-case конструкциях)
-fno-stack-protector (отключение стекового индикатора)
-fno-exceptions (позволяет корректно работать с исключениями)

***
Теперь для  локальных переменных и параметров были выделены постоянные регистры соответствующих размеров, вместо выделения места на стеке, что ускоряет работу программы. 
В функции readValue:
 - rbp[-8] -> xmm2

В функции readValueFromFile:
 - rbp[-24] -> r15
 - rbp[-8] -> r14
 - rbp[-16] -> xmm2
 
 В функции  outputResultToFile:
 - rbp[-32] -> r15
 
  В функции  computeResult:
 - rbp[-40] -> xmm2
 - rbp[-8] -> xmm3
 - rbp[-16] -> xmm4
 - rbp[-24] -> r14d
 - rbp[-28] -> r15d

***
Так же из всех функций были убраны излишние конструкции по типу двойного переноса значения по регистрам. Пример:
	    
	    mov	    rax, QWORD PTR -32[rbp]
		movq    xmm0, rax 

Переписанный вариант:

	    movq	xmm0, xmm3
***
Оптимизирован процесс обращения по индексу массива, где это было возможно. Пример:

        mov     rax, r13
        add     rax, 8
        mov     rax, QWORD PTR [rax]


Переписанный вариант:

        mov     rax, QWORD PTR [r13+8]


***
Использование регистров и рефакторинг позволил ускорить программу и сократить количество строк в нашем коде.

## Часть на 7.
Программа была разделена на несколько единиц компиляции как на языке С, так и на ассемблере. 

Программа на С собиралась с помощью следующих команд:

    $ gcc -c functions.c -o functions.o

	$ gcc -c program.c -o program.o

	$ gcc functions.o program.o -o separated-program -lm

Программа на ассемблере собирается с помощью makefile, который компонует производный файл из ассемблерных файлов functions.s и program.s.

Чтобы собрать файл на базе ассемблера использовалась команда:

    $ make -f makefile

***
В итоге получили два исполняемых файла с несколькими единицами компиляции. 
Файл на С: separated-program-c
Файл на ассемблере: separated-program-assembler
***
У обеих программ работающий ввод/вывод данных через консоль и файлы. 
Для работы через консоль запускаем исполняемые файлы, как прежде:

    $ ./separated-program-assembler

Для работы с файлами необходимо передать имена файлов, как аргументы, т.е. входного и выходного:

	$ ./separated-program-assembler input.in output.out

Производится проверка командной строки на корректность вводимых аргументов.

## Часть на 8.
Программа была модифицирована возможностью генерировать числа. Сгенерированное число выводится в консоль, после чего посчитанный результат выводится в выходной файл. Так же была использована функция для замера времени выполнения программы. 

Для наглядности замеров мы искусственно замедляем работу программы за счет добавления цикла на 3000000 итераций. 
***

Командная строка теперь может принимать вместо входного файла флаг, как аргумент, который будет означать, что необходимо сгенерировать входное число.

Так выглядит запрос для "быстрой" генерации числа и вывода ответа в файл:

    ./separated-program-assembler -g output.out
Так выглядит запрос для "долгой" (то есть с прогоном вычислений по 3 млн. итераций) генерации числа и вывода ответа в файл:

    ./separated-program-assembler -s output.out
***

Было проведено тестирование 10 раз на сгенерированных данных. 

Программа на С:
Elapsed time: 1.062867
Elapsed time: 8.002065
Elapsed time: 2.229005
Elapsed time: 1.222943
Elapsed time: 3.484296
Elapsed time: 2.160554
Elapsed time: 2.040943
Elapsed time: 45.107511
Elapsed time: 3.321665
Elapsed time: 4.132043

Программа на Ассемблере:
Elapsed time: 1.021377
Elapsed time: 7.831049
Elapsed time: 2.150131
Elapsed time: 1.318268
Elapsed time: 3.362102
Elapsed time: 2.012642
Elapsed time: 1.970695
Elapsed time: 26.922527
Elapsed time: 3.195672
Elapsed time: 4.114758

По результатам видно, что программа на ассемблере работает немного быстрее, чем программа на С. На тесте, который выполнялся дольше всех отрыв стал еще более заметен. В среднем программа на ассемблере справляется лучше на ~0.075s. При этом игнорируем аномально большой разрыв при подсчете этого среднего отклонения.
